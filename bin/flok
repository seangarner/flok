#!/usr/bin/env node
var colors = require('colors');
var path = require('path');
var fs = require('fs');
var flatten = require('mout/array/flatten');
var invoke = require('mout/array/invoke');
var filter = require('mout/array/filter');
var some = require('mout/array/some');
var logger = require('../lib/logger');


/**
 * keep other bin files dry by having options and flok creation reusable
 */
function flokme(program, requirements) {
  var flokjs = require('..');

  // load args from flok.opts
  if (!needHelp()) loadConfig(program);

  // pre-parse argv for --modules, load them and call `onCli` so they can register options and
  // commands and send back a function to be executed when program is parsed
  var mods = loadModules(program, requirements);

  // setup common options required to create a flok instance
  program
    .option('-m, --migrations <path>', 'path to migrations', path.resolve('migrations'))
    .option('--no-builtInLock', 'never load the file based locking')
    .option('--no-builtInStatus', 'never load status from files in migrations')
    .option('-l, --level <level>', 'log at trace, debug, info, warn, error, alert, fatal', 'info')
    .option('-v, --verbose', 'shortcut for `--level debug --log`');

  program.parse(process.argv);

  // new flok instance with console logger
  var flok = new flokjs.Flok({
    migrationsDir: path.resolve(program.migrations),
    lockFile: path.join(path.resolve(program.migrations), 'flok.lock')
  });
  flok.extend(logger);

  return flok;
}


function main() {
  // fix executing subcommands when being run via a symlink
  var desymlinkified = path.join(__dirname, path.basename(process.argv[1]));
  process.argv[1] = desymlinkified;

  var program = require('commander');

  program
    .version(require('../package').version)
    .usage('[command] [options]')
    .command('show [mode]', 'show migrations information')
    .command('up',          'run up migrations')
    .command('down',        'back out 1 migration at a time')
    .command('init',        'create a new migration using a generator')
    .command('lock',        'override flok locking')
    .command('fix',         'repair blocked migrations');

  // load flok.opts
  if (!needHelp()) loadConfig(program);
  // load --modules
  loadModules(program);

  program.parse(process.argv);

  // catch when we don't have any args at all
  if (!program.args.length) program.help();

  // catch the exit code of a child pid if we've executed a command via a file
  if (program.runningCommand) {
    program.runningCommand.on('exit', function (code) {
      process.exit(code);
    });
  } else {
    // we're not running a command, check we were given a valid command
    if (!some(program.commands, { _name: program.args[0] })) {
      console.error('unrecognised command:', program.args.join(' '), '\nTry --help');
    }

  }

}

//--- export when we're being require()'d
if (require.main !== module) {
  module.exports.my = flokme;
  module.exports.loadModules = loadModules;

//--- or run standalone when we aren't
} else {
  main();
}
